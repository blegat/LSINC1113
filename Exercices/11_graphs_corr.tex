\section*{1. Notions de base}

\begin{solution}
    \text{ }
    \begin{enumerate}
        \item Détermination des espaces \( V_i \) et \( E_i \) :
        Pour \( G_1 \) :
        \begin{itemize}
            \item Nœuds (\( V_1 \)) : \( V_1 = \{1, 2, 3, 4, 5, 6\} \)
            \item Arêtes (\( E_1 \)) : non orienté, donc \( E_1 = \{\{1, 2\}, \{1, 3\}, \{2, 3\}, \{2, 4\}, \{2, 5\}, \{2, 6\}, \\ 
            \{4, 5\}, \{5, 6\}, \{5, 6\}\} \)
        \end{itemize}
        
        Pour \( G_2 \) :
        \begin{itemize}
            \item Nœuds (\( V_2 \)) : \( V_2 = \{1, 2, 3, 4, 5, 6\} \)
            \item Arêtes (\( E_2 \)) : orienté, donc \( E_2 = \{(1, 4), (1, 2), (5, 2), (2, 3), (2, 6), (3, 2), (4, 4)\} \)
        \end{itemize}

        Pour \( G_3 \) :
        \begin{itemize}
            \item Nœuds (\( V_3 \)) : \( V_3 = \{1, 2, 3, 4, 5, 6, 7, 8\} \)
            \item Arêtes (\( E_3 \)) : non orienté, donc \( E_3 = \{\{1, 2\}, \{1, 3\}, \{2, 3\}, \{3, 4\}, \{4, 5\}, \{1, 6\}, \\
            \{6, 7\}, \{6, 8\}, \{7, 8\}\} \)
        \end{itemize}

        \item Détermination des degrés des nœuds :
        Pour \( G_1 \) :
        \begin{itemize}
            \item \( \deg(1) = 2 \) (arêtes vers 2, 3)
            \item \( \deg(2) = 5 \) (arêtes vers 1, 3, 4, 5, 6)
            \item \( \deg(3) = 2 \) (arêtes vers 1, 2)
            \item \( \deg(4) = 2 \) (arêtes vers 2, 5)
            \item \( \deg(5) = 4 \) (arêtes vers 2, 4, 6, 6)
            \item \( \deg(6) = 3 \) (arêtes vers 2, 5, 5)
        \end{itemize}

        Pour \( G_2 \) : \\
        Degrés entrants (\( \deg^-\)) :
        \begin{itemize}
            \item \( \deg^-(1) = 0 \)
            \item \( \deg^-(2) = 2 \) (arêtes venant de 1, 5)
            \item \( \deg^-(3) = 2 \) (arêtes venant de 2, 2)
            \item \( \deg^-(4) = 1 \) (arête venant de lui-même)
            \item \( \deg^-(5) = 0 \)
            \item \( \deg^-(6) = 1 \) (arête venant de 2)
        \end{itemize}
        Degrés sortants (\( \deg^+\)) :
        \begin{itemize}
            \item\( \deg^+(1) = 2 \) (arêtes vers 4, 2)
            \item\( \deg^+(2) = 3 \) (arêtes vers 3, 6, 3)
            \item\( \deg^+(3) = 1 \) (arête vers 2)
            \item\( \deg^+(4) = 1 \) (arête vers lui-même)
            \item\( \deg^+(5) = 1 \) (arête vers 2)
            \item\( \deg^+(6) = 0 \)
        \end{itemize}

        Pour \( G_3 \) : 
        \begin{itemize}
            \item \( \deg(1) = 3 \) (arêtes vers 2, 3, 6)
            \item \( \deg(2) = 2 \) (arêtes vers 1, 3)
            \item \( \deg(3) = 3 \) (arêtes vers 1, 2, 4)
            \item \( \deg(4) = 2 \) (arêtes vers 3, 5)
            \item \( \deg(5) = 1 \) (arête vers 4)
            \item \( \deg(6) = 3 \) (arêtes vers 1, 7, 8)
            \item \( \deg(7) = 2 \) (arêtes vers 6, 8)
            \item \( \deg(8) = 2 \) (arêtes vers 6, 7)
        \end{itemize}

        \item Vérification des propriétés :
        Pour \( G_1 \) :
        \begin{itemize}
            \item Simple : non (arête multiple entre 5 et 6).
            \item Orienté : non.
        \end{itemize}
        
        Pour \( G_2 \) :
        \begin{itemize}
            \item Simple : Oui (pas d'arêtes multiples ni de boucles sauf sur \( 4 \), mais une boucle est autorisée dans un graphe orienté).
            \item Orienté : Oui.
        \end{itemize}

        Pour \( G_3 \) :
        \begin{itemize}
            \item Simple : Oui (pas d'arêtes multiples ni de boucles).
            \item Orienté : Non.
        \end{itemize}

    \end{enumerate}
\end{solution}

\begin{solution}
    \text{ }
    \begin{itemize}
        \item Graphe \( G_1 \) : \\
         Degrés des sommets :
         \begin{itemize}
            \item \( \deg(1) = 2 \)
            \item \( \deg(2) = 3 \) (impaire)
            \item \( \deg(3) = 2 \)
            \item \( \deg(4) = 2 \)
            \item \( \deg(6) = 1 \) (impaire)
         \end{itemize}
        Sommets de degré impair : 2 sommets. \\

        Conclusion :  \( G_1 \) possède une piste eulérienne (deux sommets de degré impair). Il ne possède pas de tour eulérien (tous les degrés ne sont pas pairs).

        \item Graphe \( G_2 \) : \\
        Degrés des sommets :
        \begin{itemize}
            \item \( \deg(1) = 2 \)
            \item \( \deg(2) = 4 \)
            \item \( \deg(3) = 2 \)
            \item \( \deg(4) = 2 \)
            \item \( \deg(6) = 2 \)
        \end{itemize}
        Sommets de degré impair : Aucun. \\

        Conclusion : \( G_2 \) possède un tour eulérien (tous les degrés sont pairs, et le graphe est connexe). Il possède donc aussi une piste eulérienne.

        \item Graphe \( G_3 \) : \\
        Degrés des sommets :
        \begin{itemize}
            \item \( \deg(1) = 3 \) (impaire)
            \item \( \deg(2) = 3 \) (impaire)
            \item \( \deg(3) = 3 \) (impaire)
            \item \( \deg(4) = 2 \)
            \item \( \deg(6) = 1 \) (impaire)
        \end{itemize}
        Sommets de degré impair : 4 sommets. \\

        Conclusion : \( G_3 \) ne possède ni piste ni tour eulérien (car il y a plus de deux sommets de degré impair).

        \item Graphe \( G_4 \) : \\
        Degrés des sommets :
        \begin{itemize}
            \item \( \deg(1) = 2 \)
            \item \( \deg(2) = 2 \)
            \item \( \deg(3) = 2 \)
            \item \( \deg(4) = 2 \)
            \item \( \deg(5) = 2 \)
            \item \( \deg(6) = 2 \)
        \end{itemize}
        Sommets de degré impair : 0. \\
        
        Conclusion : \( G_4 \) possède un tour eulérien (tous les degrés sont pairs, et le graphe est connexe). Il possède donc aussi une piste eulérienne. 
    \end{itemize}

\end{solution}

\begin{solution}
    On considère chaque état comme un nœud et le passage de chaque frontière comme une arrête. 
    
    \begin{enumerate}
        \item Etats et leurs degrés :
        \begin{itemize}
            \item California (CA) : \( \deg = 2 \) (NV, AZ)
            \item Nevada (NV) : \( \deg = 3 \) (UT, AZ, CA)
            \item Utah (UT) : \( \deg = 3 \) (NV, AZ, CO)
            \item Colorado (CO) : \( \deg = 4 \) (OK, KS, NM, UT)
            \item Kansas (KS) : \( \deg = 2 \) (CO, OK)
            \item Arizona (AZ) : \( \deg = 4 \) (UT, NV, CA, NM)
            \item New Mexico (NM) : \( \deg = 4 \) (CO, TX, OK, AZ)
            \item Texas (TX) : \( \deg = 2 \) (NM, OK)
            \item Oklahoma (OK) : \( \deg = 4 \) (KS, CO, TX, NM)
        \end{itemize}

        \item Sommets de degré impair : NV et UT, on a donc deux sommets de degré impair.

        \item Conclusion sur les propriétés eulériennes : le graphe possède deux sommets de degré impair. Il existe donc une piste eulérienne mais pas de tour eulérien car tous les sommets n'ont pas un degré pair. \\

        Il est possible de traverser chaque frontière exactement une fois. La piste eulérienne doit commencer à \( NV \) ou \( UT \) et se terminer à l’autre. La règle mathématique utilisée est la caractérisation des pistes et tours eulériens.
        
    \end{enumerate}

\end{solution}

\begin{solution}
    \text{ }
    \begin{enumerate}
        \item Approche top-down : elle repose sur la décomposition récursive avec stockage des résultats intermédiaires. \\
        
        Formule générale :
        \[
        y_{n,k} =
        \begin{cases}
        1 & \text{si } n = 0, \\
        0 & \text{si } n < 0 \text{ ou } k = 0, \\
        y_{n,k-1} + y_{n-p_k,k} & \text{sinon.}
        \end{cases}
        \]

        \begin{itemize}
            \item \( y_{n,k-1} \) représente le nombre de façons de faire \( n \) en excluant la pièce \( p_k \).
            \item \( y_{n-p_k,k} \) représente le nombre de façons de faire \( n \) en incluant au moins une fois la pièce \( p_k \).
        \end{itemize}

        Prenons \( n = 5 \) et les pièces \( \{1, 2, 5\} \), avec \( p_1 = 1, p_2 = 2 \text{ et } p_3 = 5\). Nous voulons calculer \( y_{5,3} \), le nombre de façons de faire 5 avec ces pièces.
        \[
        y_{5,3} = y_{5,2} + y_{5-p_3,3} = y_{5,2} + y_{0,3}
        \]
        \begin{itemize}
            \item \( y_{5,2} \) : Façons de faire \( 5 \) sans utiliser la pièce 5. On peut le décomposer \( y_{5,2} = y_{5,1} + y_{5-p_2,2} = y_{5,1} + y_{3,2} \).
            \item \( y_{0,3} \) : Façons de faire \( 0 \) avec les pièces \( \{1, 2, 5\} \). \( \implies y_{0,3} = 1 \) : Il y a une seule façon de faire \( 0 \) : ne rien prendre.
        \end{itemize}

        On continue la décomposition : 
        \begin{itemize}
            \item \( y_{5,1} \) : Façons de faire \( 5 \) sans utiliser la pièce 2. \( y_{5,1} = 1 \) : Si on n’utilise que des pièces de 1, il n’y a qu’une seule façon de faire \( 5 \).
            \item \( y_{3,2} \) : Façons de faire \( 3 \) en incluant au moins une pièce de 2. \( y_{3,2} = y_{3,1} + y_{3-p_2,2} = y_{3,1} + y_{1,2} \). \( y_{3,1} = 1 \) : Façons de faire \( 3 \) avec uniquement des pièces de 1. Puis, \( y_{1,2} = y_{1,1} + y_{1-p_2,2} = y_{1,1} + y_{-1,2} \) avec \( y_{1,1} = 1 \) car uniquement des pièces de 1 et \( y_{-1,2} = 0 \) est une somme négative.
        \end{itemize}

        Cela donne finalement: 
        \[
        y_{5,3} = y_{5,2} + y_{0,3} = (y_{5,1} + y_{3,2}) + 1 = (1 + (y_{3,1} + y_{1,2})) + 1
        \]
        \[
        y_{5,3} = (1 + (1 + 1)) + 1 = 4
        \]

        Il y adonc 4 façon de faire la somme \( 5 \) avec les pièces \( \{1, 2, 5\} \) :
        \begin{enumerate}
            \item \( 1 + 1 + 1 + 1 + 1 \),
            \item \( 1 + 1 + 1 + 2 \),
            \item \( 1 + 2 + 2 \),
            \item \( 5 \).
        \end{enumerate}

    Top-down signifie que nous partons du problème principal et le décomposons récursivement en sous-problèmes (\( y_{n,k-1} \) et \( y_{n-p_k,k} \)). À chaque étape, nous stockons les résultats des sous-problèmes pour éviter de les recalculer inutilement. Finalement, nous remontons les résultats des sous-problèmes pour calculer la solution finale.

        \begin{lstlisting}
def top_down_approach(n, coins, memo={}):
    assert len(coins) != 0, "Vérifier la variable coins"

    if n == 0:
        return 1
    if n < 0:
        return 0
    if (n, len(coins)) in memo:
        return memo[(n, len(coins))]
    
    include_k = top_down_approach(n - coins[-1], coins, memo)
    exclude_k = top_down_approach(n, coins[:-1], memo) 

    memo[(n, k)] = include_k + exclude_k
    return memo[(n, k)]
        \end{lstlisting}

        \item Approche bottom-up : elle consiste à résoudre le problème de manière itérative, en calculant les solutions des plus petits sous-problèmes jusqu'au problème principal. On construit une table \( dp \), où chaque \( dp[i][j] \) représente le nombre de façons de faire la somme \( i \) avec les \( j \) premières pièces. \\
        
        Formule mathématique : \\
        On initialise \( dp[0][j] = 1 \) pour tout \( j \), car il n’y a qu’une seule façon de faire la somme 0 : ne rien prendre.
        \[
        dp[0][j] = 1 \quad \text{pour tout } j
        \]
        \[
        dp[i][0] = 0 \quad \text{pour tout } i > 0
        \]

        La récurrence : 
        \[
        dp[i][j] = dp[i][j-1] + dp[i-p_j][j],
        \]
        où on considère la j-ième pièce de la valeur \( p_j \), \( dp[i][j-1] \) est le nombre de façons de faire \( i \) sans utiliser la pièce \( p_j \) et \( dp[i-p_j][j] \) est le nombre de façons de faire \( i \) en incluant au moins une fois la pièce \( p_j \). \\
        
        On remplit ensuite le tableau \( dp[i][j] \)t, en utilisant la relation de récurrence.

        Si on reprend l'exemple précédent \( n = 5 \), pièces \( \{1, 2, 5\} \). On crée un tableau \( dp \) de dimensions \( (n+1) \times (k+1) \), où \( n = 5 \) (somme cible) et \( k = 3 \) (nombre de pièces).

        \begin{table}[!h]
        \centering
        \begin{tabular}{|c|c|c|c|c|}
        \hline
         \textbf{i} & \( dp[i][0] \) & \( dp[i][1] \) & \( dp[i][2] \) & \( dp[i][3] \) \\ \hline
         \textbf{0} & 1 & 1 & 1 & 1 \\ \hline
         \textbf{1} & 0 & 0 & 0 & 0 \\ \hline
         \textbf{2} & 0 & 0 & 0 & 0 \\ \hline
         \textbf{3} & 0 & 0 & 0 & 0 \\ \hline
         \textbf{4} & 0 & 0 & 0 & 0 \\ \hline
         \textbf{5} & 0 & 0 & 0 & 0 \\ \hline
        \end{tabular}
        \end{table}

        Pour \( j = 1 \), c'est-à-dire qu'on ne considère que la pièce \( 1 \)) pour trouver le nombre de façons de faire la somme \( i \):
        \[
        dp[i][1] = dp[i][0] + dp[i-p_1][1]
        \]
        \( dp[i][0] = 0 \), donc :
        \[
        dp[i][1] = dp[i-1][1]
        \]

        Le tableau devient donc :
       
        \begin{table}[!h]
        \centering
        \begin{tabular}{|c|c|c|c|c|}
        \hline
         \textbf{i} & \( dp[i][0] \) & \( dp[i][1] \) & \( dp[i][2] \) & \( dp[i][3] \) \\ \hline
         \textbf{0} & 1 & 1 & 1 & 1 \\ \hline
         \textbf{1} & 0 & 1 & 0 & 0 \\ \hline
         \textbf{2} & 0 & 1 & 0 & 0 \\ \hline
         \textbf{3} & 0 & 1 & 0 & 0 \\ \hline
         \textbf{4} & 0 & 1 & 0 & 0 \\ \hline
         \textbf{5} & 0 & 1 & 0 & 0 \\ \hline
        \end{tabular}
        \end{table}

        Pour \( j = 2 \) et on considère les pièces \( \{1, 2\} \) :
        \[
        dp[i][2] = dp[i][1] + dp[i-p_2][2]
        \]

        Calculons pour chaque \( i \) :
        \begin{itemize}
            \item \( dp[1][2] = dp[1][1] + dp[-1][2] = 1 + 0 = 1 \),
            \item \( dp[2][2] = dp[2][1] + dp[0][2] = 1 + 1 = 2 \),
            \item \( dp[3][2] = dp[3][1] + dp[1][2] = 1 + 1 = 2 \),
            \item \( dp[4][2] = dp[4][1] + dp[2][2] = 1 + 2 = 3 \),
            \item \( dp[5][2] = dp[5][1] + dp[3][2] = 1 + 2 = 3 \).
        \end{itemize}

        Pour \( j = 3 \) (pièces \( \{1, 2, 5\} \)) :
        \[
        dp[i][3] = dp[i][2] + dp[i-p_3][3]
        \]

        On a donc :
        \begin{itemize}
            \item \( dp[1][3] = dp[1][2] + dp[-4][3] = 1 + 0 = 1 \)
            \item \( dp[2][3] = dp[2][2] + dp[-3][3] = 2 + 0 = 2 \),
            \item \( dp[3][3] = dp[3][2] + dp[-2][3] = 2 + 0 = 2 \),
            \item \( dp[4][3] = dp[4][2] + dp[-1][3] = 3 + 0 = 3 \),
            \item \( dp[5][3] = dp[5][2] + dp[0][3] = 3 + 1 = 4 \).
        \end{itemize}

        Le tableau final est : 
        
        \begin{table}[!h]
        \centering
        \begin{tabular}{|c|c|c|c|c|}
        \hline
         \textbf{i} & \( dp[i][0] \) & \( dp[i][1] \) & \( dp[i][2] \) & \( dp[i][3] \) \\ \hline
         \textbf{0} & 1 & 1 & 1 & 1 \\ \hline
         \textbf{1} & 0 & 1 & 1 & 1 \\ \hline
         \textbf{2} & 0 & 1 & 2 & 2 \\ \hline
         \textbf{3} & 0 & 1 & 2 & 2 \\ \hline
         \textbf{4} & 0 & 1 & 3 & 3 \\ \hline
         \textbf{5} & 0 & 1 & 3 & 4 \\ \hline
        \end{tabular}
        \end{table}
        
        Le résultat final est \( dp[5][3] = 4 \), ce qui signifie qu'il y a 4 façons de faire la somme \( 5 \) avec les pièces \( \{1, 2, 5\} \). \\
        
        Dans l’approche top-down, nous utilisons une relation de récurrence pour résoudre le problème. Tandis que dans l’approche bottom-up, nous partons des cas de base et que nous construisons progressivement toutes les solutions jusqu’au problème principal (\( dp[n][k] \)). L'approche bottom-up est généralement plus rapide et plus adaptée pour des grands problèmes, car elle évite la surcharge due à la récursivité. \\

        \begin{lstlisting}
def bottom_up_approach(n, coins):
    dp = [[0 for _ in range(len(coins) + 1)] for _ in range(n + 1)]
    for j in range(len(coins) + 1):
        dp[0][j] = 1 

    for i in range(1, n + 1):
        for j in range(1, len(coins) + 1):
            if i - coins[j - 1] >= 0:
                dp[i][j] = dp[i][j - 1] + dp[i - coins[j - 1]][j]
            else:
                dp[i][j] = dp[i][j - 1]

    return dp[n][len(coins)]
        \end{lstlisting}

        \item Formule alternative 
        
        \begin{lstlisting}
def alternative_approach(n, coins):
    dp = [0] * (n + 1)
    dp[0] = 1  # Une seule façon de faire 0

    for coin in coins:
        for i in range(coin, n + 1):
            dp[i] += dp[i - coin]

    return dp[n]
        \end{lstlisting}

    Cette formule est légèrement différente, car elle regroupe les calculs par groupes (multiples des pièces disponibles). Cela peut être plus rapide en pratique si n est très grand et que l’ensemble des pièces est limité. La formule alternative est souvent plus rapide pour des pièces spécifiques (comme ${1,2,5,10}$), car elle réduit la redondance des calculs.

    \end{enumerate}

\end{solution}