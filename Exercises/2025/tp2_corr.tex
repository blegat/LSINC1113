\session{Correction TP2 - Principe de récurrence et ordre de grandeur}

\section*{1. Equation caractéristique et superposition}

\begin{solution}
\textbf{ } \\
\textbf{Méthode :} on résout d’abord la partie homogène (polynôme caractéristique), puis on cherche une solution particulière adaptée au second membre, et on détermine les constantes par les conditions initiales.

\begin{enumerate}
\item $\displaystyle x_{n+2}+3 \cdot x_{n+1}+2 \cdot x_n=5\cdot 3^n,\quad x_0=0,\ x_1=1.$ \\

\textit{Homogène :} $r^2+3r+2=0\ \Rightarrow\ (r+1)(r+2)=0\ \\
\Rightarrow\ \text{les racines sont donc } r=-1,-2.$  \\
Cela donne comme solution homogène : $\displaystyle x_n^{(h)}=A(-1)^n+B(-2)^n.$ \\

\textit{Particulière :} $5\cdot 3^n$. \\
Il n'y a pas de résonance car $3$ n’est pas racine de la solution homogène. \\
$\Rightarrow$ On essaye $x_n^{(p)}=A\,3^n$. \\
On remplace dans l'équation de récurrence : $A\,3^{n+2}+3 \cdot A\,3^{n+1}+2 \cdot A\,3^n=5\cdot 3^n$ \\
On peut factoriser $3^n$: \\
$3^{n}(9A+9A+2A)=20A\cdot 3^n=5\cdot 3^n \Rightarrow A=\tfrac14.$ \\

\textit{Générale :} $\displaystyle x_n=A(-1)^n+B(-2)^n+\frac{1}{4}\,3^n.$

\textit{CI :} \\
$x_0=0 \Rightarrow A+B+\tfrac14=0$ ; \\
$x_1=1 \Rightarrow -A-2B+\tfrac34=1 \\
\Rightarrow -A-2B=\tfrac14.$  
On en déduit $B=0$, $A=-\tfrac14$.

\[
\boxed{\,x_n=\frac14\big(3^n-(-1)^n\big)\,}
\] \\

\item $\displaystyle y_{n+2}-4y_{n+1}+4y_n=1,\quad y_0=0,\ y_1=3.$ \\

\textit{Homogène :} $r^2-4r+4=(r-2)^2=0$. \\
On a donc une racine double, $r = 2$. \\
Cela donne comme solution homogène $\displaystyle y_n^{(h)}=(A+Bn)\,2^n.$ \\

\textit{Particulière :} Le second membre est constant $1$, on essaye $y_n^{(p)}=K$. \\
On remplace dans l'équation de récurrence : $K-4K+4K=K=1 \Rightarrow K=1$. Il n'y a pas de résonance car $1$ n'est pas solution de l'équation homogène). \\

\textit{Générale :} $\displaystyle y_n=(A+Bn)\,2^n+1.$

\textit{CI :} \\
$y_0=0 \Rightarrow A+1=0 \Rightarrow A=-1.$ \\ 
$y_1=3 \Rightarrow 2(A+B)+1=3 \Rightarrow A+B=1 \Rightarrow B=2.$

\[
\boxed{\,y_n=(2n-1)\,2^n+1\,}
\] \\

\item $\displaystyle z_n+6z_{n-1}+9z_{n-2}=16\,n,\quad z_0=2,\ z_1=2.$ \\

\textit{Homogène :} On pose $z_n = r^n$ \\
$r^n + 6r^{n-1} + 9r^{n-2} = 0 \Rightarrow r^{n-2} (r^2 + 6r + 9) = 0 \Rightarrow (r+3)^2 = 0$ \\
On a donc une racine double $-3$. \\
$\displaystyle z_n^{(h)}=(A+Bn)\,(-3)^n$ \\

\textit{Particulière :} $16n$ \\
Le second membre est un polynôme de degré 1, on essaye $z_n^{(p)}=an+b$. \\
Alors,
\[
z_{n-1}^{(p)} = a(n-1) + b = an + (b-a)
\]
\[
z_{n-2}^{(p)} = a(n-2) + b = an + (b-2a) 
\]
Substitution dans l'équation :
\[
(an + b) + 6 (an + b - a) + 9 (an + b - 2a) = 16n
\]
\[
16 an + 16 b - 24 a = 16n
\]
$\Rightarrow a=1$ et $16b-24=0 \Rightarrow b=\tfrac{3}{2}$. \\

\textit{Générale :} $\displaystyle z_n=(A+Bn)\,(-3)^n + (n+\tfrac{3}{2}).$

\textit{CI :} \\
$z_0=2 \Rightarrow A+\tfrac{3}{2}=2 \Rightarrow A=\tfrac{1}{2}.$  \\
$z_1=2 \Rightarrow -3(A+B)+\tfrac{5}{2}=2 \Rightarrow A+B=\tfrac{1}{6} \Rightarrow B=-\tfrac{1}{3}.$

\[
\boxed{\,z_n=\Big(\tfrac12-\tfrac{n}{3}\Big)(-3)^n+n+\tfrac{3}{2}\,}
\] \\

\item $\displaystyle v_{n+2}=2\,(v_{n+1}-v_n),\quad v_0=1,\ v_1=2.$ \\

\textit{Homogène :} $v_{n+2}-2v_{n+1}+2v_n=0 \Rightarrow r^2-2r+2=0.$ \\
\[
\Delta = -4 = i^2 4
\]
\[
r = \frac{2 \pm 2i}{2} = 1 \pm i
\]

Pour exploiter ces racines, on écrit : 
\[
1 + i = \sqrt{2} \cdot \exp(\frac{i \pi}{4}), \quad 1 - i = \sqrt{2} \cdot \exp(\frac{-i \pi}{4})
\]

Cela signifie que les solutions générales sont des combinaisons linéaires de 
\[
(1 + i)^n = (\sqrt{2})^n \cdot \exp(\frac{i n \pi}{4}), \quad (1 - i)^n = (\sqrt{2})^n \cdot \exp(\frac{-i n \pi}{4})
\]

En développant Euler, 
\[
\alpha (\sqrt{2})^n (\cos{(n \pi / 4)} + i \sin{(n \pi / 4)}) + \beta (\sqrt{2})^n (\cos{(n \pi / 4)} - i \sin{(n \pi / 4)})
\]
\[
\Rightarrow (\sqrt{2})^n (\alpha + \beta) (\cos{(n \pi / 4)} + (\sqrt{2})^n (\alpha - \beta ) i \sin{(n \pi / 4)})
\]

Comme la suite doit être réelle, 
\[
(\alpha + \beta) \text{ doit être réel et } i(\alpha - \beta) \text{ doit être réelle aussi}
\]

Soit $\alpha = a + i b$ et $\beta = u + iv$ :
Donc la partie imaginaire de $(\alpha + \beta)$ vaut 0 donc $b + v = 0$ et la partie imaginaire de $i(\alpha - \beta)$ vaut 0 donc $a - u = 0$.
On tombe donc sur $\alpha$ est le conjugué de $\beta$ ce qui nous donne finalement, comme forme réelle :
\[
v_n=(\sqrt2)^n\big(C\cos(n\pi/4)+D\sin(n\pi/4)\big).
\]

\textit{CI :} $v_0=1 \Rightarrow C=1.$  \\
$v_1=2 \Rightarrow (\sqrt2)\big(\tfrac{\sqrt2}{2}C+\tfrac{\sqrt2}{2}D\big)=C+D=2 \Rightarrow D=1.$

\[
\boxed{\,v_n=(\sqrt2)^n\big(\cos(n\pi/4)+\sin(n\pi/4)\big)\,}
\]
\end{enumerate}
\end{solution}

\begin{solution}
    Pour que $x_{n+1}=-\dfrac{15}{x_n}$ soit un \textbf{entier}, il faut et il suffit que $\dfrac{15}{x_n}\in\mathbb{Z}$, c’est-à-dire

    $$
    x_n \mid 15 \quad\text{(“\(x_n\) divise 15”)}.
    $$
    
    Donc chaque terme $x_n$ doit être un diviseur entier non nul de 15 :
    
    $$
    \mathcal D=\{\pm1,\ \pm3,\ \pm5,\ \pm15\}.
    $$
    
    En particulier, c’est nécessaire que $x_0\in\mathcal D$ (et bien sûr $x_0\neq 0$ pour éviter la division par zéro).

    Réciproquement, si on choisit $x_0=d\in\mathcal D$, alors

    $$
    x_1=-\frac{15}{d}\in\mathcal D,\qquad
    x_2=-\frac{15}{x_1}=-\frac{15}{-15/d}=d=x_0.
    $$
    
    Donc
    
    $$
    \boxed{x_{n+2}=x_n\ \text{ pour tout }n,}
    $$
    
    la suite est périodique de période 2 (un 2-cycle) et reste entière.
    
    Forme explicite (pour $d=x_0\in\mathcal D$) :
    
    $$
    \boxed{\,x_{2k}=d,\qquad x_{2k+1}=-\dfrac{15}{d}\quad(k\ge0).\,}
    $$

    \textit{Conclusion :}\\
    La récurrence admet une solution entière si et seulement si

    $$
    \boxed{\,x_0\in\{\pm1,\ \pm3,\ \pm5,\ \pm15\}\, .}
    $$
    
    Dans ce cas, la suite est périodique de période 2 :
    
    $$
    x_0=d,\ x_1=-\frac{15}{d},\ x_2=d,\ x_3=-\frac{15}{d},\ \dots
    $$
    
    Exemples :
    \begin{enumerate}
        \item $x_0=3 \Rightarrow  (3,\,-5,\,3,\,-5,\dots)$
        \item $x_0=-15 \Rightarrow (-15,\,1,\,-15,\,1,\dots)$
        \item $x_0=5 \Rightarrow (5,\,-3,\,5,\,-3,\dots)$
    \end{enumerate} 

    (Cas interdit : $x_0=0$, car on ne peut pas définir $x_1$).
\end{solution}

\begin{solution}
    \text{ } \\
    Soit:
    \begin{itemize}
        \item $E_n$ = nombre de mots de longueur $n$ avec un \textbf{nombre pair} de $d$,
        \item $O_n$ = nombre de mots de longueur $n$ avec un \textbf{nombre impair} de $d$.
    \end{itemize}

Bases: $E_0=1$ (le mot vide a 0 $d$, pair) et $O_0=0$. \\

Construisons un mot de longueur $n\!+\!1$ en ajoutant une lettre à droite d’un mot de longueur $n$. Si on ajoute $a,b$ ou $c$ (3 choix), on ne change pas la parité du nombre de $d$. Si on ajoute $d$ (1 choix), on bascule la parité, un mot avec un nombre impair de d devient pair et vice versa. \\

Donc:
\begin{itemize}
    \item Pour être pair à l’étape $n\!+\!1$, on vient soit d’un mot pair + $a/b/c$ (3·$E_n$), soit d’un mot impair + $d$ (1·$O_n$): 
    $$
    E_{n+1}=3E_n+O_n.
    $$
    \item Pour être impair à l’étape $n\!+\!1$, on vient soit d’un mot impair + $a/b/c$ (3·$O_n$), soit d’un mot pair + $d$ (1·$E_n$):
    $$
    O_{n+1}=E_n+3O_n.
    $$
\end{itemize}

Sous forme matricielle:

$$
\begin{pmatrix}E_{n+1}\\ O_{n+1}\end{pmatrix}
=
\underbrace{\begin{pmatrix}3&1\\[2pt]1&3\end{pmatrix}}_{T}
\begin{pmatrix}E_n\\ O_n\end{pmatrix},
\qquad
\begin{pmatrix}E_0\\ O_0\end{pmatrix}=\begin{pmatrix}1\\ 0\end{pmatrix}.
$$

D’où $\binom{E_n}{O_n}=T^n\binom{1}{0}$. \\

On va résoudre la récurrence, via diagonalisation. La matrice $T$ a pour valeurs propres ($\det(T - \lambda I) = 0$) $\lambda_1=4$ et $\lambda_2=2$, avec vecteurs propres $(T - \lambda I) v = 0$
$v_1=\binom{1}{1}$ et $v_2=\binom{1}{-1}$.
On décompose le vecteur initial. Pour arriver à ça : on cherche $\alpha,\beta$ tels que

$$
\binom10=\alpha\binom11+\beta\binom1{-1}.
$$

Cela donne le système

$$
\begin{cases}
\alpha+\beta=1,\\
\alpha-\beta=0.
\end{cases}
\quad\Longrightarrow\quad
\alpha=\beta=\tfrac12.
$$

Donc

$$
\binom10=\tfrac12\binom11+\tfrac12\binom1{-1}.
$$

Alors

$$
\binom{E_n}{O_n}
= \tfrac12\,4^n\binom{1}{1}+\tfrac12\,2^n\binom{1}{-1}
= \binom{\tfrac{4^n+2^n}{2}}{\tfrac{4^n-2^n}{2}}.
$$

Finalement, 

$$
\boxed{\,E_n=\frac{4^n+2^n}{2}\,}
\quad\text{et}\quad
O_n=\frac{4^n-2^n}{2}.
$$

\end{solution}

\begin{solution}
    \text{ }\\
    On veut montrer, pour tout entier $n\ge 1$,
    
    $$
    S_n=\sum_{k=1}^n k^2=\frac{n(n+1)(2n+1)}{6}.
    $$

\textbf{1) Initialisation}

Pour $n=1$,

$$
S_1=1^2=1
\quad\text{et}\quad
\frac{1\cdot(1+1)\cdot(2\cdot1+1)}{6}=\frac{1\cdot2\cdot3}{6}=1.
$$

Donc la propriété est vraie au rang $1$. \\

\textbf{2) Hérédité}

Supposons la formule vraie pour un certain $n\ge1$ (hypothèse de récurrence) :

$$
S_n=\sum_{k=1}^n k^2=\frac{n(n+1)(2n+1)}{6}.
$$

Montrons-la au rang $n+1$. On part de

$$
S_{n+1}=\sum_{k=1}^{n+1}k^2
= \underbrace{\sum_{k=1}^{n}k^2}_{S_n} + (n+1)^2.
$$

En remplaçant $S_n$ par l’hypothèse de récurrence :

$$
S_{n+1}=\frac{n(n+1)(2n+1)}{6}+(n+1)^2.
$$

Factorisons $(n+1)$ :

$$
S_{n+1}
=(n+1)\left(\frac{n(2n+1)}{6} + (n+1)\right).
$$

Mettons tout au même dénominateur :

$$
S_{n+1}
=(n+1)\left(\frac{2n^2+n}{6} + \frac{6n+6}{6}\right)
=(n+1)\cdot \frac{2n^2+7n+6}{6}.
$$

Factorisons le polynôme :

$$
2n^2+7n+6=(2n+3)(n+2).
$$

Donc

$$
S_{n+1}=(n+1)\cdot \frac{(2n+3)(n+2)}{6}
=\frac{(n+1)(n+2)(2n+3)}{6}.
$$

Or

$$
\frac{(n+1)(n+2)\big(2(n+1)+1\big)}{6}
=\frac{(n+1)(n+2)(2n+3)}{6},
$$

ce qui est exactement la formule au rang $n+1$. \\

\textbf{3) Conclusion}

La propriété est vraie au rang $1$ et héréditaire de $n$ à $n+1$. Par principe de récurrence, pour tout $n\ge1$,

$$
\boxed{\;\sum_{k=1}^n k^2=\frac{n(n+1)(2n+1)}{6}\;}
$$

est démontré.

\end{solution}

% \begin{solution}
% \text{ }
%     \begin{enumerate}
%         \item On veut calculer $a^n$ avec a un nombre entier. La méthode naïve serait de multiplier $a$ par lui même $n-1$ fois, ça donnerait $O(n)$ multiplications. Par exemple, pour $a^{1000}$, ça fait $999$ multiplications, c'est trop, long si $n$ est grand. \\
        
%         Un algorithme d’exponentiation rapide (aussi appelé exponentiation binaire) sert à calculer $a^n$ beaucoup plus vite que la méthode naïve. Idée : on exploite l’écriture binaire de $n$ pour ne faire qu’$O(\log n)$ multiplications (au lieu de $O(n)$). \\

%         \textbf{Idée clé.} Pour calculer $a^n$ vite, on exploite :
%         \begin{itemize}
%             \item si n est pair : $a^n = (a^2)^{n/2}$
%             \item si n est impair : $a^n = a \cdot (a^2)^{(n-1)/2}$
%         \end{itemize}

%         $n$ étant binaire, on peut l'écrire comme $n=\sum_{k=0}^{m} b_k 2^k$ avec $b_k\in\{0,1\}$. Alors, 
%         \[
%         a^n = \prod_k a^{b_k 2^k} = \prod_{k | b_k = 1} a^{2^k}
%         \]

%         Or cela revient juste à mettre $k$ fois la base au carré seulement quand le bit vaut 1. \\

        
%         Ecrivons : 
%         \[
%         \texttt{res}\cdot \texttt{base}^{\texttt{exp}} \;=\; a^{n}\quad(\text{invariant}).
%         \]

%         Au départ $\texttt{res}=1$, $\texttt{base}=a$, $\texttt{exp}=n$. \\
%         À chaque tour:
%         \begin{itemize}
%           \item si $\texttt{exp}$ est impair: $\texttt{res}\leftarrow \texttt{res}\cdot \texttt{base}$; si $\texttt{exp}$ est pair: $\texttt{res}\leftarrow \texttt{res}$
%           \item on met \emph{toujours} la base au carré: $\texttt{base}\leftarrow \texttt{base}^2$;
%           \item on décale $\texttt{exp}$ d'un bit: $\texttt{exp}\leftarrow \lfloor \texttt{exp}/2\rfloor$ (division entière).
%         \end{itemize}

%         Par exemple $3^{13}$:
%         \begin{enumerate}
%             \item $\texttt{res} = 1$ ; $\texttt{base} = 3$ ;  $\texttt{exp} = 13$
%             \item \texttt{exp} est impair ; $\texttt{res} = 1 * 3 = 3$ ;$\texttt{base} = 3^2 = 9$ ;  $\texttt{exp} = 6$
%             \item \texttt{exp} est pair ; $\texttt{res} = 3$ ;$\texttt{base} = 9^2 = 81$ ;  $\texttt{exp} = 3$
%             \item \texttt{exp} est impair ; $\texttt{res} = 3 * 81 = 243$ ;$\texttt{base} = 81^2 = 6561$ ;  $\texttt{exp} = 1$
%             \item \texttt{exp} est impair ; $\texttt{res} = 6561 * 243 = 1594323$ ;$\texttt{base} = 6561^2 = 43046721$ ;  $\texttt{exp} = 0$
%         \end{enumerate}

%         On a donc $3^{13} = 1594323$. \\

%         \textbf{Complexité :} à chaque tour, on divise l'exposant par 2 donc $\log_2(n)$, puis par itération, on a 1 carré et parfois une accumulation (quand le bit vaut 1). La complexité reste donc en $O(\log(n))$ alors que pour la version naïve qui est de faire $n-1$ multiplication la complexité est de $O(n)$. \\

%         \newpage

%         \textbf{Algorithme (pseudo-code).}
%         \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
%         # a^n, version naive : O(n)
%         function pow_naive(a, n::Integer)
%             n < 0 && throw(ArgumentError("n >= 0 requis"))
%             res = one(a)
%             for _ in 1:n
%                 res *= a
%             end
%             return res
%         end
        
%         # a^n, exponentiation rapide : O(log n)
%         function pow_fast(a, n::Integer)
%             n < 0 && throw(ArgumentError("n >= 0 requis"))
%             res, base, exp = one(a), a, n
%             while exp > 0
%                 if isodd(exp)
%                     res *= base          # bit courant = 1
%                 end
%                 base *= base             # carré
%                 exp  >>= 1               # division entière par 2
%             end
%             return res
%         end
%         \end{lstlisting}

%         \item Même schéma en remplaçant $1$ par $I_2$ et les multiplications par des produits matriciels. Invariant: $R\cdot B^{e}=A^{n_0}$. \\

%         \textbf{Complexité.} Même nombre d’itérations $\Theta(\log n)$; à chaque tour: 1 carré + (éventuellement) 1 accumulation $\Rightarrow O(\log n)$ produits de matrices (avec un facteur constant plus grand que le cas scalaire). \\
        
%         \textbf{Algorithme (pseudo-code).}
%         \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
%         identity2(T::Type) = [one(T) zero(T); zero(T) one(T)]
%         identity2(A::AbstractMatrix) = identity2(eltype(A))
        
%         function matmul2(A::AbstractMatrix, B::AbstractMatrix)
%             @assert size(A)==(2,2) && size(B)==(2,2)
%             C11 = A[1,1]*B[1,1] + A[1,2]*B[2,1]
%             C12 = A[1,1]*B[1,2] + A[1,2]*B[2,2]
%             C21 = A[2,1]*B[1,1] + A[2,2]*B[2,1]
%             C22 = A[2,1]*B[1,2] + A[2,2]*B[2,2]
%             return [C11 C12; C21 C22]
%         end
        
%         function mat_pow_naive(A::AbstractMatrix, n::Integer)
%             @assert size(A)==(2,2)
%             n < 0 && throw(ArgumentError("n >= 0"))
%             R = identity2(A)
%             for _ in 1:n
%                 R = matmul2(R, A)
%             end
%             return R
%         end
        
%         function mat_pow_fast(A::AbstractMatrix, n::Integer)
%             @assert size(A)==(2,2)
%             n < 0 && throw(ArgumentError("n >= 0"))
%             R, B, e = identity2(A), A, n
%             while e > 0
%                 if isodd(e)
%                     R = matmul2(R, B)
%                 end
%                 B = matmul2(B, B)
%                 e >>= 1
%             end
%             return R
%         end
%         \end{lstlisting}

%         \item Tester par exemple:
%         \[
%         \text{scalaire: } a=3,\ n=10^3,10^6 \quad\text{et}\quad
%         \text{matrice: } M=\begin{psmallmatrix}1&1\\1&0\end{psmallmatrix},\ n=10^3,10^6.
%         \]
%         En Julia (avec \texttt{@time} ou \texttt{BenchmarkTools.@btime}):
%         \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
%         @time pow_naive(3, 10^6);   
%         @time pow_fast(3, 10^6);
        
%         M = [1 1; 1 0]
%         @time mat_pow_naive(M, 10^6);
%         @time mat_pow_fast(M, 10^6);
%         \end{lstlisting}
%         Attendu: la version rapide devient nettement plus rapide pour $n$ grand,
%         car $O(\log n)$ vs $O(n)$.
        
%     \end{enumerate}
% \end{solution}

\begin{solution}
    \text{ }
    \begin{enumerate}
        \item Pour calculer, $a^n$, on va vouloir faire $a \cdot a \cdot \cdot a$ ($n-1$ multiplications en $O(n)$) mais plus $n$ devient grand plus cela va devenir long. Un algorithme d’exponentiation rapide (aussi appelé exponentiation binaire) sert à calculer $a^n$ beaucoup plus vite que la méthode naïve. L'idée c'est d'exploiter l’écriture binaire de $n$ pour ne plus faire qu’$O(\log n)$ multiplications (au lieu de $O(n)$). \\
        De plus, le fait que diviser l'exposant par 2 est moins coûteux : 
        \begin{itemize}
            \item si $n$ est pair : $a^n = (a^2)^{n/2}$ ;
            \item si $n$ est impair : $a^n = a \cdot (a^2)^{(n-1)/2}$.
        \end{itemize}

        $n$ étant binaire, on peut l'écrire comme $n=\sum_{k=0}^{m} b_k 2^k$ avec $b_k\in\{0,1\}$. Alors, 
        \[
        a^n = \prod_k a^{b_k 2^k} = \prod_{k | b_k = 1} a^{2^k}
        \]

        Or cela revient juste à mettre $k$ fois la base au carré seulement quand le bit vaut 1. \\

        
        Ecrivons : 
        \[
        \texttt{res}\cdot \texttt{base}^{\texttt{exp}} \;=\; a^{n}\quad(\text{invariant}).
        \] 

        Au départ $\texttt{res}=1$, $\texttt{base}=a$, $\texttt{exp}=n$. \\
        À chaque tour:
        \begin{itemize}
          \item si $\texttt{exp}$ est impair: $\texttt{res}\leftarrow \texttt{res}\cdot \texttt{base}$; si $\texttt{exp}$ est pair: $\texttt{res}\leftarrow \texttt{res}$
          \item on met \emph{toujours} la base au carré: $\texttt{base}\leftarrow \texttt{base}^2$;
          \item on décale $\texttt{exp}$ d'un bit: $\texttt{exp}\leftarrow \lfloor \texttt{exp}/2\rfloor$ (division entière).
        \end{itemize}
        \text{ }

        Par exemple $3^{13}$:
        \begin{enumerate}
            \item $\texttt{res} = 1$ ; $\texttt{base} = 3$ ;  $\texttt{exp} = 13$
            \item \texttt{exp} est impair ; $\texttt{res} = 1 * 3 = 3$ ;$\texttt{base} = 3^2 = 9$ ;  $\texttt{exp} = 6$
            \item \texttt{exp} est pair ; $\texttt{res} = 3$ ;$\texttt{base} = 9^2 = 81$ ;  $\texttt{exp} = 3$
            \item \texttt{exp} est impair ; $\texttt{res} = 3 * 81 = 243$ ;$\texttt{base} = 81^2 = 6561$ ;  $\texttt{exp} = 1$
            \item \texttt{exp} est impair ; $\texttt{res} = 6561 * 243 = 1594323$ ;$\texttt{base} = 6561^2 = 43046721$ ;  $\texttt{exp} = 0$
        \end{enumerate}

        On a donc $3^{13} = 1594323$. \\

        \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
        function pow_fast(a, n::Integer)
            n < 0 && throw(ArgumentError("n => 0 requis"))
            res, base, exp = one(a), a, n
            while exp > 0
                if isodd(exp)
                    res *= base
                end
                base *= base
                exp >>= 1
            end
            return res
        end
        \end{lstlisting}

        \item C'est exactement la même idée mais on remplace $1$ par l'identité $I_2$ et les multiplications deviennent par le produit matriciel. 
        De plus, on calcule le modulo $m$ pour éviter l’explosion de la taille des nombres (qui croissent exponentiellement), garder tous les calculs bornés dans $[0,m-1]$ donc faisables, et comme la réduction est un homomorphisme $((AB)\bmod m = ((A\bmod m)(B\bmod m))\bmod m)$, on obtient le **même résidu** que si l’on réduisait à la fin. \\

        Le code devient :
        \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
        function mul2(A, B; m::Integer=0)
            C11 = A[1,1]*B[1,1] + A[1,2]*B[2,1]
            C12 = A[1,1]*B[1,2] + A[1,2]*B[2,2]
            C21 = A[2,1]*B[1,1] + A[2,2]*B[2,1]
            C22 = A[2,1]*B[1,2] + A[2,2]*B[2,2]
            if m != 0
                C11 %= m; C12 %= m; C21 %= m; C22 %= m
            end
            return [C11 C12; C21 C22]
        end

        function mat_pow_fast(A, n::Integer; m::Integer=0)
            n < 0 && throw(ArgumentError("n => 0 requis"))
            R = [1 0; 0 1]
            B, e = copy(A), n
            while e > 0
                if isodd(e)
                    R = mul2(R, B; m=m)
                end
                B = mul2(B, B; m=m)
                e >>= 1
            end
            return R
        end
        \end{lstlisting}

        \item On l'applique maintenant à la récurrence $v_{n+2} = 2(v_{n+1} - v_n)$. Traduisons cela en produit de matrices : 
        
        $$
        \begin{pmatrix} v_{n+2}\\ v_{n+1}\end{pmatrix}
        =
        \underbrace{\begin{pmatrix}2&-2\\[2pt]1&0\end{pmatrix}}_{M}
        \begin{pmatrix}v_{n+1}\\ v_n\end{pmatrix}
        $$

        Par itération :
        $$
        X_n = M^n X_0, \quad X_n = \begin{pmatrix} v_{n+1} \\ v_n \end{pmatrix} \quad X_0 = \begin{pmatrix} v_{1} \\ v_0 \end{pmatrix} = \begin{pmatrix} 2\\ 1 \end{pmatrix}.
        $$

        Donc, 
        $$
        v_n = (M^n \begin{pmatrix} 2 \\ 1 \end{pmatrix})_2
        $$

        Le polynôme caractéristique de la partie homogène est $\lambda^2 -2\lambda + 2 = 0$ a comme racines $1\pm i = \sqrt{2} \exp{(\pm i \pi / 4)}$ (cf. exercice 12).

        Donc, 
        \[
        v_n = (\sqrt{2})^n (\cos{(\frac{n \pi}{4})} + \sin{(\frac{n \pi}{4})}).
        \]
        

        \begin{lstlisting}[basicstyle=\ttfamily\small, mathescape=true]
        function v_of(n::Integer; m::Integer=0)
            n < 0 && throw(ArgumentError("n => 0 requis"))
            if n == 0
                return m == 0 ? 1 : 1 % m)
            end
            M = [2 -2; 1 0]
            V = mat_pow_fast(M, n; m=m) * [2; 1]
            return m == 0 ? V[2] : Int(V[2] % m)
        end
        \end{lstlisting}
        
    \end{enumerate}
\end{solution}
